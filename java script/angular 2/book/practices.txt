 * create all component structure with all basic implementation:
 - ng generate component heroes
 - it also adding this component into a app.module
 
 * The ngOnInit is a lifecycle hook Angular calls ngOnInit
 shortly after creating a component.
 It's a good place to put initialization logic.
 
 * call a object method in the html file:
 - <h2>{{ hero.name }} Details</h2>
   <div><span>id: </span>{{hero.id}}</div>
   <div><span>name: </span>{{hero.name}}</div>
 
 * create one file for static variables:
 - export class StaticLabels {
	static TITLE_PAGE: string = "faafas";
 }
 
 * components can be injected into other components:
 - <panel title="Hello World">
	 <panel title="Step 1">
		this is one text.
	 </panel>
	 <panel title="Step 2">
		this is second text.
	 </panel>
   </panel>
   
 * load the data from the project tree in the web from src folder:
 - localhost:4200/user.json 
   
 * controlling element visibiity:
 - in class: 
 - submitted:boolean;
 - in some method just set to true,
 - <div [hidden]="!submitted">element</div> 
 
 * components are injected to the high abstract class using html tags,
 
 * zamiana obiektu na JSON:
 - JSON.stringify(vid)
 
 * server returns text from the call, but i can parse it to json():
 - text.json();

 * sometimes angular 2 works bad and you have to reaload the server,
 then it will work better. Simple refresh sometimes does not work.

 * send components data between components:
 - <app-video-list [videos]="videoComponents"></app-video-list>',
 videos - jest to nazwa pola w komponencie app-video-list
 videoComponents - jest to nazwa pola przekazywanego z aktualnego komponentu
 
INPUT: 
 
 * send object to child component:
 - <app-panel title="Panel Title"></app-panel> - this will send string value to the title object in the app-panel
 - <app-panel [title]="panelTitle"></app-panel> - this will send panelTitle Object from the parent comp to the lower component
 
 * send text from higher component to the lower component:
 - <app-panel [title]="panelTitle">
	... Some text to send ...
   </app-panel>
 - this text will be seen in the ng-content area of the lower component:
   <div class="panel-body"><ng-content></ng-content></div> 
 - so, all content between those tags will be send to this component without any class variables.  
 
 * w komponencie app-video-list, obiekt można odebrać uzywająć @Input
 - before we add some value to the input, videos will be not given.(usefull for *ngIf)
 - @Input() videos;
 
  * The lower component can not directly call a method from higher comp, this is
a bad programming practice.

 * It is said that lower list components should only contain objects and dispatch events, but the
 select method should be called from high methods - confiusing!!!

 * 
 
DIRECTIVES: 

 * *ngFor can be used even with divs:
 - <div *ngFor='let message of messageService.messages'> {{message}} </div>

 * *ngIf:
 - removes html from the DOM, so there is no to worry about
 - if some object is not present during init then div with that object contents
 should be used using if directive

 * check the validation of a value:
 - jeśli input zostanie wykasowany, to zostanie wyświetlona klasa .ng-invalid (musi się zgadzać ta nazwa),
 która musi zostać zadeklarowana w pliku css naszej aplikacji,
 - jest to swego rodzaju validator,
 - może działać wraz z:
 - <label for="name">Name</label>
 <label for="name">Name</label>
    <input type="text" class="form-control"
           required [(ngModel)]="user.name" name="name1" ngControl="name">


 * two way databinding input:
 - has to contain name attribute
 - <input *ngIf="!editTitle" (click)="onTitleClick()"
  [(ngModel)]="video.title" name="not_edit"/>

 * two way data binding:
 - sometimes doesn't work, because lack of FormsModule in the app.module.ts
 - [(ngModel)]="video.url"
 
 * display list of items:
 <ul>
	<li *ngFor="let hero of heroes">
		{{ hero.name }}
	</li>
 </ul>
 
 * if statement:
 - <app-video-detail *ngIf="selectedVideo" [video]="selectedVideo"></app-video-detail>
 
EVENTS:

 * Emit an event from lower in the hierarchy component to the higher component we use: 
 - @Output() selectVideo = new EventEmitter();
 - send selected object using (vid):
 // this method emits this object to the world and from this time it can be catched
 // from others components.
 // an even does not have to emit any values, it can be track as asimple event.
 // modyfikatory dostępu nic nie psują
 - this.selectVideo.next(vid);
 
 * catch an event in higher component:
 - (selectVideo)="onSelectVideo($event)"
 - where selectVideo is a name of lower class emiter.