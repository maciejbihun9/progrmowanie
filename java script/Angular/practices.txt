 * create all component structure with all basic implementation:
 - ng generate component heroes
 - it also adding this component into a app.module
 
 * The ngOnInit is a lifecycle hook Angular calls ngOnInit
 shortly after creating a component.
 It's a good place to put initialization logic.
 
 * call a object method in the html file:
 - <h2>{{ hero.name }} Details</h2>
   <div><span>id: </span>{{hero.id}}</div>
   <div><span>name: </span>{{hero.name}}</div>
 
 * create one file for static variables:
 - export class StaticLabels {
	static TITLE_PAGE: string = "faafas";
 }
 
 * components can be injected into other components:
 - <panel title="Hello World">
	 <panel title="Step 1">
		this is one text.
	 </panel>
	 <panel title="Step 2">
		this is second text.
	 </panel>
   </panel>
   
 * load the data from the project tree in the web from src folder:
 - localhost:4200/user.json 
   
 * controlling element visibiity:
 - in class: 
 - submitted:boolean;
 - in some method just set to true,
 - <div [hidden]="!submitted">element</div> 
 
 * create an input element with already defined id field:
 - <input #heroName />
 - this is a name of a input variable, so we can get it by heroName.value
 
 * get value from input and use it as a function input parameter:
 - <input #searchBox (keyup)="search(searchBox.value)" />
 
 * components are injected to the high abstract class using html tags,
 
 * zamiana obiektu na JSON:
 - JSON.stringify(vid)
 
 * server returns text from the call, but i can parse it to json():
 - text.json();

 * sometimes angular 2 works bad and you have to reaload the server,
 then it will work better. Simple refresh sometimes does not work.

 * send components data between components:
 - <app-video-list [videos]="videoComponents"></app-video-list>',
 videos - jest to nazwa pola w komponencie app-video-list
 videoComponents - jest to nazwa pola przekazywanego z aktualnego komponentu

APPLICATION ARCHITECTURE:

 * each data change changes also ui!!!, so 
 we do not have to do any refreshes on our UI is happens automatically,

 * We packaged our searching into a seperate component,
 - all operations during searching,
 - input component and styles around him also 
 
SEARCHING:

 * searching is done ofcourse with observables,

 * import { Subject }    from 'rxjs/Subject';

 * private searchTerms = new Subject<string>();
 
 * // Push a search term into the observable stream.
search(term: string): void {
  this.searchTerms.next(term);
}

 * wywołanie metody wyszukiwania:
 - each time keyup fires then we call for a new list of items.
 - <input #searchBox id="search-box" (keyup)="search(searchBox.value)" />
 
 * describe how frequently search for an item:
 - this.heroes$ = this.searchTerms.pipe(
      // wait 300ms after each keystroke before considering the term
      debounceTime(300),

      // ignore new term if same as previous term
      distinctUntilChanged(),

      // switch to new search observable each time the term changes
      switchMap((term: string) => this.heroService.searchHeroes(term)),
    );
 - switchMap() preserves the original request order while 
 returning only the observable from the most recent HTTP method call.
 Results from prior calls are canceled and discarded.
 
LIST OPERATIONS:

 * declare html that creates items out of observable:
 - heroes$ - is a convention to declare an observable list,
 - async indicates that this subscribe automatically,
 - <li *ngFor="let hero of heroes$ | async" >

 * filter elements:
 - it is much neede when we remove elements from a list in our UI,
 because we do not want to wait for our server to response,
 - leave only elements that are not hero
 - this.heroes = this.heroes.filter(h => h !== hero); 
 
INPUT: 
 
 * send object to child component:
 - <app-panel title="Panel Title"></app-panel> - this will send string value to the title object in the app-panel
 - <app-panel [title]="panelTitle"></app-panel> - this will send panelTitle Object from the parent comp to the lower component
 
 * send text from higher component to the lower component:
 - <app-panel [title]="panelTitle">
	... Some text to send ...
   </app-panel>
 - this text will be seen in the ng-content area of the lower component:
   <div class="panel-body"><ng-content></ng-content></div> 
 - so, all content between those tags will be send to this component without any class variables.  
 
 * w komponencie app-video-list, obiekt można odebrać uzywająć @Input
 - before we add some value to the input, videos will be not given.(usefull for *ngIf)
 - @Input() videos;
 
  * The lower component can not directly call a method from higher comp, this is
a bad programming practice.

 * It is said that lower list components should only contain objects and dispatch events, but the
 select method should be called from high methods - confiusing!!!

 	


 
 
DIRECTIVES: 

 * *ngFor can be used even with divs:
 - <div *ngFor='let message of messageService.messages'> {{message}} </div>

 * *ngIf:
 - removes html from the DOM, so there is no to worry about
 - if some object is not present during init then div with that object contents
 should be used using if directive

 * check the validation of a value:
 - jeśli input zostanie wykasowany, to zostanie wyświetlona klasa .ng-invalid (musi się zgadzać ta nazwa),
 która musi zostać zadeklarowana w pliku css naszej aplikacji,
 - jest to swego rodzaju validator,
 - może działać wraz z:
 - <label for="name">Name</label>
 <label for="name">Name</label>
    <input type="text" class="form-control"
           required [(ngModel)]="user.name" name="name1" ngControl="name">


 * two way databinding input:
 - has to contain name attribute
 - <input *ngIf="!editTitle" (click)="onTitleClick()"
  [(ngModel)]="video.title" name="not_edit"/>

 * two way data binding:
 - sometimes doesn't work, because lack of FormsModule in the app.module.ts
 - [(ngModel)]="video.url"
 
 * display list of items:
 <ul>
	<li *ngFor="let hero of heroes">
		{{ hero.name }}
	</li>
 </ul>
 
 * if statement:
 - <app-video-detail *ngIf="selectedVideo" [video]="selectedVideo"></app-video-detail>
 
EVENTS:

 * list of all used events:
 - https://www.w3schools.com/jsref/dom_obj_event.asp

 * Emit an event from lower in the hierarchy component to the higher component we use: 
 - @Output() selectVideo = new EventEmitter();
 - send selected object using (vid):
 // this method emits this object to the world and from this time it can be catched
 // from others components.
 // an even does not have to emit any values, it can be track as asimple event.
 // modyfikatory dostępu nic nie psują
 - this.selectVideo.next(vid);
 
 * catch an event in higher component:
 - (selectVideo)="onSelectVideo($event)"
 - where selectVideo is a name of lower class emiter.
 
 * do a job after key up:
 - (keyup)="search(searchBox.value)"
 
 * do some jobs after click:
 - after click we can call methods and call some normal js code,
 - (click)="add(heroName.value); heroName.value=''"