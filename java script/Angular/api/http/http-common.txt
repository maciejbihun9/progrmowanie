
 * we get from the server only one item, this is a HttpResponse in an Obserable wrapper
 this is always only one item.
 - HttpResponse == Observable<HttpResponse<Type>>
 
 * only obserable is just tip, that hej, I just got data from the server!!!
 
 * I do not want to know how the json data type is parsed over the web,
 
Observable:
 
 * we can use RxJS to work with observables

INTERCEPTOR:

 * catches http calls to the server and also server responses.
 
 * is able to add some additional beheviors/informations to those calls,
 
 * it is very fast tool to add this behaviour instead of adding some additional
 behaviour to each request/response by hand, 
 
 zastosowanie:
 * we can make a request to the server, where we need for example an authentication token
 or credentials.
 this interceptor can add and handle add some additional informations to the headers of a call
 so now we can call there without 401 status,
 * adds to each call header about authorization of each call,
 * catches all errors from the server and log them to the user instead of
 getting all data with errors
 
 example:
 - https://www.youtube.com/watch?v=qnRrqH-BzJE - interceptor 
 
JSONP:

 * this is the pefect way to crack the cross-domain issues,
 
 * this is a way for communication with the server for older browsers,
 
 * to execute that i can add a function to be executed, CROS should be executed on newer browsers,
 
 * we do not have full control with errors that can occur after the request,

 * if there is a script that lives on the server under other domain.
 using a url we can call that script and this script may contain some data
 that we can use,

 * JSONP is a method for sending JSON data without worrying about cross-domain issues.

 * JSONP does not use the XMLHttpRequest object.

 * JSONP uses the <script> tag instead. 

HTTP_INTERCEPTORS:

 * this is some kind of a injection token,
 
 * the only method is toString() that prints its name,
 
HttpResponse:

 * this object should be returned in each http call, because we have here full set of informations
 from the server, 
 
HttpBackend:

 * sends requests,

 * sends requests directly to the backend without ?interceptor? chains,

 * his handle() method consumes http requests and sends them directly to the backend
 there is no interceptors involved here,
 
 * I think that this method of sending calls to the server works much faster,
 
HttpClient:

 * this is the basic module to handle communication with the server,

 * contains the most basic set of method to do it,

 * request through the chain of registered interceptors and on to the server,
 so i think that this method works a bit slower than normal communication
 without it,

 * get() returns an observable of some type and maps this type with the body of the json,
 - this will be fully constructed object from body from the web, 
 
 * each method is almost the same, follows the same concept, takes the same parameters
 
 * it is all about presenting the data in the same type,
 
 zastosowanie:
 * under this url we know that lives an array of objects:
 - this.http.get<Hero[]>(this.heroesUrl)
 
HttpClientJsonpModule: 

 * we need this module to interact with some script from other domains,
 
 * this module just has to be in the program,
 
 * which enables JSONP support in HttpClient.
 
 * thanks to that this protection can be disabled,
 
HttpClientXsrfModule:

 * can configure XSRF protection with correct cookie and header names, 
 
 * protects from those calls
 
HttpErrorResponse:

 * is returned when there are some problems during the http call,
 bad url or call to the server returns some error after processing,
 
 * this will prevent from throwing it to the browser,
 
 * any error during a call will be wrapped into it,
 
 * example:
 import 'rxjs/add/operator/catch';
 import 'rxjs/add/observable/throw';
 
 - this is possible because this type of error is thrown any time
 errorHandler(error: HttpErrorResponse){
    return Observable.throw(error.message || "Server error");
  }

  getForError(): Observable<Hero[]>{
    var badUrl: string = "dsadsa";
    return this.http.get<Hero[]>(badUrl)
      .pipe(
        tap(heroes => this.log(`fetched heroes`)),
        catchError(this.errorHandler)
      );
  }
  
 - catch it in some component:
 public errorMsg: string;
 getErrorHeroes(){
    return this.heroService.getForError()
      .subscribe((heroes) => this.heroes = heroes,
                 error => this.errorMsg = error);
  } 
  
HTTPEVENT:

 * do rozkminki

HttpHeaders:

 * we can set this during creating of our new method for posting or adding new items to the server,
 - const httpOptions = {
  headers: new HttpHeaders({ 'Content-Type': 'application/json' })
 };
 - we can set those options in the post method body

 * after each subscription we can get the HttpResponse from the server,
 * we can get it from the subscribe() mthod body
 - this.heroService.getHeroesResponse().subscribe(data => {
      console.log(data);
      console.log(data.headers);
      var keys = data.headers.keys();
    });
 * so data is a HttpResponse object, from which we can get httpHeaders instance, 
 from where we can get some specific informations, 
 
HttpResponse:

 * is a type of an HttpEvent, httpEvent is an event that can occur in the network,

 * this object is returned from an obserable subscription,
 
 * see the httpResponse for more informations what we can get from this response,
 
 * for sure... headers, informations important for the server in json type,
 
HttpUrlEncodingCodec:

 * uses urlEncoder to encode and ecode url parameters,
 
 * we have to do it because url comment text can be received as a set of key=value pairs
 other than sended text,
 
HttpXhrBackend:

 * An HttpBackend which uses the XMLHttpRequest API to send requests to a backend server,

 * the seperate implementation does not work here, it throws some difficult to diagnose errors,
 
 * does not do any diffferent jobs than others do,
 
XhrFactory:

 * this is just wrapper for XMLXttpRequest object,

 * should not be used seperatley, HttpClient should be used! 

 