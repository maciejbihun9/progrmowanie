
OBSERVABLE SUBJECT PATTERNS:

 * communication between comps can be done in many ways.
 One of the best is to use an observalble, subscription pattern,

 * we can create a service that will send message from one comp to another
 which will have subscription object that,

 * I have a Subject(), I have an important subject and also I want to inform all people about that,

 * As an admin we can push messages to the subject! and all subscribers can get those messages from it,

 * this is great replacement for input and event Emmiters,

 * each person that wants to send messages to subscribers needs to have
 an instance of a Subject class. On the Subscriber side we can subscribe to this
 subject and just getting messages from there what ever a new message becomes
 available,

 * In this situation we should use
  Subject class, that is a special type of Observable,

 * video: Subscription;
 - this video is an instaince of a Subscription class, so mark this instance to look for changes in the
 relevant way,
 - each subscription object is an object that waits for an update from a owner of a subject,


 example:
 * see AngularAdanced and watcher video communication pattern

 zastosowanie:
 * sending messages to specific components

USE Rx.BehaviorSubject:

 * the instance of this class represents wartość zmienną w czasie do której można subsrybować,
 także działa niemal tak samo jak subject,

 * te osoby dostają nową wartość po tym jak będzie ona dostępna! - zajebiste,

SENDING AN OBJECT INSTANCE TO LOWER COMPONENTS,

 * If we want to manage only one state for a component, then we have to create an Injectable service
 that manages state of that component. this can be injected in any place and it will be available in any place
 where it was injected.

 * @Input() in lower component receives instance, so this is a reference to an object not a simple label!!,
 once changed, this new variable can be used in different places depends on when we subscribe to that subject.

 * send an instance of an object to lower objects and change states there

 * those properties of an instance will be also changed in upper object

EVENT EMMITERS:

  * Emit an event from lower in the hierarchy component to the higher component we use:
  - @Output() selectVideo = new EventEmitter();
  - send selected object using (vid):
  // this method emits this object to the world and from this time it can be catched
  // from others components.
  // an even does not have to emit any values, it can be track as simple event.
  // modyfikatory dostępu nic nie psują
  - this.selectVideo.next(vid);

  * catch an event in higher component:
  - (selectVideo)="onSelectVideo($event)"
  - where selectVideo is a name of lower class emiter.

  * we can also emit many variables at once:
  - this.scroll.emit({
          direction,
          scrollYPos: this.scrollYPos,
          scrollXPos: this.scrollXPos
        });


