
 * To summarize: the first crucial fact about decorators is that they have the power to
replace the decorated function with a different one. The second crucial fact is that they
are executed immediately when a module is loaded. This is explained next.

 * decorator looks like a simple function, but we use it totally different
 def register(func):
	print('running register(%s)' % func)
	registry.append(func)
	return func

 @register
 def f1():
	print('running f1()')

 @register
 def f2():
	print('running f2()')
	
- those decorators runs right after module import	
- decorators runs right at the beginning
so before method is called register prints all contents	of each method,
- create a decorator (this is like a another function, but with inner function) 
- this is a simple example of changing methods behevoiurs,
- from the start it sounds crazy, because this is just simple methods replcement
- runs when module is loaded
>>> def deco(func):
		def inner():
			print('running inner()')
>>> @deco
	def target():
		print('running target()')
		
>>> target()
... running inner()
>>> target
<function deco.<locals>.inner at 0x10063b598>

 * those decorators can be used when I want to add all decorated functions
 into a somekind of a list and then just call them later.
 - {func() for func in functions}

 * when we want to adjust our function before processing 
 
 CLOSURES:
 
 * it is all about using a inner functions,
 
 * we use it when we want to create a global scope that is global only for a specific function,
 
 * example:
 def make_averager():
	series = []
	def averager(new_value):
		series.append(new_value)
		total = sum(series)
		return total/len(series)
	return averager
	
>>> avg = make_averager()
>>> avg(10)
10.0
>>> avg(11)
10.5
>>> avg(12)
11.0	

 * previous approach was not efficient for our problem, because we stored all values there
def make_averager():
	count = 0
	total = 0
	
	def averager(new_value):
		nonlocal count, total
		count += 1
		total += new_value
		return total / count
	return averager

>>> avg = make_averager()
>>> avg(10)	
 - those variables have to declared as a nonlocal, because they are immutable, so we create
 a new variables each time when we enter this function.
 - using nonlocal we declare that those variables are not local, so are global 
 and we can use it,
 
 
 - Remember that this code:
@clock
def factorial(n):
	return 1 if n < 2 else n*factorial(n-1)

 - Actually does this:

def factorial(n):
	return 1 if n < 2 else n*factorial(n-1)

factorial = clock(factorial)
 
 VARIABLE SCOPE RULES:
 
 * do not use global scope ever!!!
 
 * watch out with global variables:
 >>> b = 6
>>> def f2(a):
	... print(a)
	... print(b)
... b = 9
f2(3)
 - this will cause an error because b is declared as a local scope, so that global
 variable won't work, because the generated byte code won't allow us to do it,
 this works like java script, but there we use var keyword,
 
 * to omit this error we have declare that this variable becomes from global scope:
 def f3(a):
    global b
    print(a)
    print(b)
    b = 3
 - this will work and prints b from global scope	

